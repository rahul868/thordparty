import {
  React,
  useState,
  useRef,
  createContext,
  useContext,
  useEffect,
} from "react";
import { Gcommoncontext } from "./common_global";
import { upload_doc } from "@/utils/fileuploading";

const Rhscontext = createContext();
const Rhsprovider = (props) => {
  //Global context
  const { user, currdoc, setcurrdoc, setfilemeta, setgindicatormsg } =
    useContext(Gcommoncontext);

  // Storage for actual file data uploaded which will remove after uploading.
  const [files, setfiles] = useState([]);
  const messagesContainerRef = useRef(null);

  // Chats state for storing chat API status and data
  const [SavedMessages, setSavedMessages] = useState([]);
  const [loading, setloading] = useState(true);
  const [error, seterror] = useState(null);

  // group creation for storing chat API status and data
  const [gastatus, setgastatus] = useState(false);
  const [gamsg, setgamsg] = useState("");
  const [gatype, setgatype] = useState("l");

  const [chatsetting, setchatsetting] = useState({
    response_mode: "efficient",
    answers_length: "medium",
    content_source: "focused",
  });

  //   [
  //   {
  //     isChatAi: true,
  //     re_type: "normal",
  //     timestamp: 1701848854312,
  //     avatar:
  //       "https://w7.pngwing.com/pngs/704/673/png-transparent-openai-chatgpt-logo-thumbnail.png",
  //     summary:
  //       "This is a piece of advice on how to write data in an application. It suggests that writing data sequentially can improve the chances of it being stored sequentially. It also recommends avoiding frequent file create/delete operations to maintain sequential storage.",
  //   },
  //   {
  //     isChatAi: false,
  //     avatar:
  //       "https://media.licdn.com/dms/image/D4D03AQF7koLJD5QU9A/profile-displayphoto-shrink_200_200/0/1668317728846?e=1706140800&v=beta&t=NO7GVdYTkuJXZs8jFunyyVNDHFSOXsbB8ON8EA88uOc",
  //     summary: "How to handle discord billons of messages in scylladb ?",
  //   },
  //   {
  //     isChatAi: true,
  //     re_type: "html",
  //     source: "From test.doc 2 page example.com",
  //     avatar:
  //       "https://w7.pngwing.com/pngs/704/673/png-transparent-openai-chatgpt-logo-thumbnail.png",
  //     summary: `<html lang="en">
  //     <head>
  //         <meta charset="UTF-8">
  //         <meta name="viewport" content="width=device-width, initial-scale=1.0">
  //         <title>Embedded Beautiful Message</title>
  //         <style>
  //             * {
  //                 box-sizing: border-box;
  //                 margin: 0;
  //                 padding: 0;
  //             }

  //             .message-container {
  //                 max-width: 600px;
  //                 margin: 20px auto;
  //                 background-color: #f8f8f8;
  //                 border-radius: 8px;
  //                 box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  //                 overflow: hidden;
  //             }

  //             .message-header {
  //                 background-color: #3498db;
  //                 color: #fff;
  //                 padding: 20px;
  //                 text-align: center;
  //             }

  //             .message-body {
  //                 padding: 20px;
  //             }

  //             .message-content {
  //                 color: #333;
  //                 margin-bottom: 20px;
  //             }

  //             .message-paragraph {
  //                 margin-bottom: 20px;
  //             }

  //             .message-list {
  //                 list-style: none;
  //                 padding: 0;
  //                 margin: 0;
  //             }

  //             .message-list-item {
  //                 margin-bottom: 8px;
  //             }

  //             .message-list-item:before {
  //                 content: 'â€¢';
  //                 color: #3498db;
  //                 display: inline-block;
  //                 width: 1em;
  //                 margin-left: -1em;
  //                 margin-right: 8px;
  //             }

  //             .message-footer {
  //                 text-align: center;
  //                 padding: 10px;
  //                 background-color: #f2f2f2;
  //             }
  //         </style>
  //     </head>

  //     <body>

  //     <div class="message-container">
  //         <div class="message-header">
  //             <h2>Beautiful Message</h2>
  //         </div>
  //         <div class="message-body">
  //             <p class="message-content">This is a beautiful message generated by AI. It includes paragraphs and bullet points.</p>

  //             <p class="message-paragraph">Paragraph 1: Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>

  //             <ul class="message-list">
  //                 <li class="message-list-item">Bullet point 1</li>
  //                 <li class="message-list-item">Bullet point 2</li>
  //                 <li class="message-list-item">Bullet point 3</li>
  //             </ul>

  //             <p class="message-paragraph">Paragraph 2: Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>
  //         </div>
  //         <div class="message-footer">
  //             <p>Footer content or additional information.</p>
  //         </div>
  //     </div>

  //     </body>
  //     </html>`,
  //   },
  //   {
  //     isChatAi: false,
  //     avatar:
  //       "https://media.licdn.com/dms/image/D4D03AQF7koLJD5QU9A/profile-displayphoto-shrink_200_200/0/1668317728846?e=1706140800&v=beta&t=NO7GVdYTkuJXZs8jFunyyVNDHFSOXsbB8ON8EA88uOc",
  //     summary: "How to handle discord billons of messages in scylladb ?",
  //   },
  //   {
  //     isChatAi: true,
  //     re_type: "normal",
  //     source: "From test.doc 2 page example.com",
  //     avatar:
  //       "https://w7.pngwing.com/pngs/704/673/png-transparent-openai-chatgpt-logo-thumbnail.png",
  //     summary:
  //       "This is a piece of advice on how to write data in an application. It suggests that writing data sequentially can improve the chances of it being stored sequentially. It also recommends avoiding frequent file create/delete operations to maintain sequential storage.",
  //   },
  //   {
  //     isChatAi: false,
  //     avatar:
  //       "https://media.licdn.com/dms/image/D4D03AQF7koLJD5QU9A/profile-displayphoto-shrink_200_200/0/1668317728846?e=1706140800&v=beta&t=NO7GVdYTkuJXZs8jFunyyVNDHFSOXsbB8ON8EA88uOc",
  //     summary: "How to handle discord billons of messages in scylladb ?",
  //   },
  //   {
  //     isChatAi: true,
  //     re_type: "html",
  //     source: "From test.doc 2 page",
  //     avatar:
  //       "https://w7.pngwing.com/pngs/704/673/png-transparent-openai-chatgpt-logo-thumbnail.png",
  //     summary: `
  //     <!DOCTYPE html>
  //     <html lang="en">
  //     <head>
  //         <meta charset="UTF-8">
  //         <meta name="viewport" content="width=device-width, initial-scale=1.0">
  //         <title>Simple Embedded Message</title>
  //         <style>

  //             .message-container {
  //                 background-color: #fff;
  //                 border-radius: 6px;
  //                 box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  //                 overflow: hidden;
  //                 max-width: 300px;
  //                 width: 100%;
  //             }

  //             .message-header {
  //                 background-color: #4CAF50;
  //                 color: #fff;
  //                 padding: 15px;
  //                 text-align: center;
  //             }

  //             .message-content {
  //                 padding: 20px;
  //                 text-align: center;
  //             }

  //             .message-button {
  //                 background-color: #4CAF50;
  //                 border: none;
  //                 color: #fff;
  //                 padding: 10px 20px;
  //                 text-align: center;
  //                 text-decoration: none;
  //                 display: inline-block;
  //                 font-size: 16px;
  //                 margin-top: 15px;
  //                 cursor: pointer;
  //                 border-radius: 4px;
  //             }
  //         </style>
  //     </head>
  //     <body>

  //     <div class="message-container">
  //         <div class="message-header">
  //             <h2>Simple Message</h2>
  //         </div>
  //         <div class="message-content">
  //             <p>This is a simple and different embedded message. Feel free to customize it!</p>
  //             <button class="message-button">Click Me</button>
  //         </div>
  //     </div>

  //     </body>
  //     </html>
  //     `,
  //   },
  //   {
  //     isChatAi: false,
  //     avatar:
  //       "https://media.licdn.com/dms/image/D4D03AQF7koLJD5QU9A/profile-displayphoto-shrink_200_200/0/1668317728846?e=1706140800&v=beta&t=NO7GVdYTkuJXZs8jFunyyVNDHFSOXsbB8ON8EA88uOc",
  //     summary: "How to handle discord billons of messages in scylladb ?",
  //   },
  //   {
  //     isChatAi: true,
  //     re_type: "normal",
  //     timestamp: 1701848854312,
  //     avatar:
  //       "https://w7.pngwing.com/pngs/704/673/png-transparent-openai-chatgpt-logo-thumbnail.png",
  //     summary:
  //       "This is a piece of advice on how to write data in an application. It suggests that writing data sequentially can improve the chances of it being stored sequentially. It also recommends avoiding frequent file create/delete operations to maintain sequential storage.",
  //   },
  // ]

  // Function for fetching chat hostory of individual doc

  const fetchFileChats = async () => {
    try {
      // Simulate API call for user file metadata
      const response = await fetch(
        `${process.env.NEXT_PUBLIC_API_URL}/chatHistory?email=${user.email}&fileid=${currdoc.id}`
      );
      if (!response.ok) {
        throw new Error("Failed to fetch user files");
      }
      const chats_data = await response.json();
      setSavedMessages(chats_data.data);
    } catch (err) {
      seterror(err.message);
    } finally {
      setloading(false);
    }
  };

  // Function for sending created group to backend for persistent purpose.
  const setUserGroup = async (groupobj) => {
    setgaloading(true);
    try {
      // Simulate API call for user file metadata
      const response = await fetch(
        `${process.env.NEXT_PUBLIC_API_URL}/process_document_group?emailid=${user.email}`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json", // content type based on your API requirements
          },
          body: JSON.stringify(groupobj),
        }
      );
      if (!response.ok) {
        throw new Error("Failed to update group");
      }
      const files = await response.json();
      setfilemeta((prevFiles) => [groupobj, ...prevFiles]);
      setgasuccess(true);
      setTimeout(() => {
        setgasuccess(false);
        setgaerror(false);
      }, 4000);
      return { success: true };
    } catch (err) {
      setgaerror(err.message);
      setTimeout(() => {
        setgaerror(false);
      }, 4000);
      return { success: false };
    } finally {
      setgaloading(false);
    }
  };

  const cloud_upload = async () => {
    files.forEach(async (file) => {
      await upload_doc(file);
    });
  };

  const setSeperateFiles = async (files) => {
    setgastatus(true);
    setgatype("l");
    setgamsg("Document is processing please wait...");
    try {
      // Simulate API call for user file metadata
      const response = await fetch(
        `${process.env.NEXT_PUBLIC_API_URL}/process_documents?emailid=${user.email}`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json", // content type based on your API requirements
          },
          body: JSON.stringify(files),
        }
      );
      if (!response.ok) {
        throw new Error("Failed to update group");
      }
      const result = await response.json();
      setfilemeta((prevFiles) => [...files, ...prevFiles]);
      setcurrdoc(files[0]);
      setgatype("s");
      setgamsg("Document processed successfully.");
      setTimeout(() => {
        setgastatus(false);
        setgatype("l");
        setgamsg("");
      }, 4000);
      return { success: true };
    } catch (err) {
      setgatype("e");
      setgamsg("Something went wrong please try again.");
      setTimeout(() => {
        setgastatus(false);
        setgatype("l");
        setgamsg("");
      }, 4000);
      return { success: false };
    } finally {
      // setgastatus(false);
      // setgatype("l");
      // setgamsg("");
    }
  };

  useEffect(() => {
    if (currdoc) {
      setloading(true);
      fetchFileChats();
    }
  }, [currdoc]);

  const save_chats_local = (currfile) => {
    // First API call will go here.
    window.localStorage.setItem(
      `doc_${currfile}`,
      JSON.stringify(SavedMessages)
    );
    setgindicatormsg("Chats saved.");
  };

  const del_chats_local = (currfile) => {
    console.log(`doc_${currfile}`);
    console.log(window.localStorage.getItem(`doc_${currfile}`));
    window.localStorage.removeItem(`doc_${currfile}`);
  };

  // const/ [SelectGroupChat, setSelectGroupChat] = useState();

  return (
    <Rhscontext.Provider
      value={{
        SavedMessages,
        setSavedMessages,
        messagesContainerRef,
        setfiles,
        files,
        save_chats_local,
        del_chats_local,
        error,
        loading,
        setUserGroup,
        gastatus,
        gamsg,
        gatype,
        setSeperateFiles,
      }}
    >
      {props.children}
    </Rhscontext.Provider>
  );
};

export { Rhscontext, Rhsprovider };
